{"version":3,"sources":["pathfindingvisualizer/Node.js","pathfindingvisualizer/MouseStrat.js","pathfindingvisualizer/Algorithms/Dikjstras.js","pathfindingvisualizer/Heuristics.js","pathfindingvisualizer/Algorithms/Astar.js","pathfindingvisualizer/Algorithms/GreedyBestFirst.js","pathfindingvisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","startnode","endnode","col","row","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","className","id","Component","originalNodeCol","originalNodeRow","mouseStartNode","mouseEndNode","drawingWalls","GeneralStrat","window","PathfindingVisualizer","grid","newGrid","getNewGridWithWallToggled","setState","mouseLeftDown","console","log","gred","slice","END_NODE_COL","END_NODE_ROW","START_NODE_COL","START_NODE_ROW","Dikjstras","startNode","endNode","visitedNodes","unvisitedNodes","getAllNodes","distance","length","sortNodesByDistance","currentNode","shift","Infinity","isVisited","updateNeighbors","push","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","nei","cur","previousNode","diagonalPathing","unvisitedNeighborsDiag","getUnvisitedNeighborsDiag","Manhattan","node","Math","abs","Octile","weight","dx","dy","sqrt","Astar","Gcost","sortNodesByDistanceThenHcost","curG","curH","round","Hcost","dist","GreedyBestFirst","sortNodesByHcost","h","sort","nodeA","nodeB","sleep","ms","Promise","resolve","setTimeout","resetWall","a","i","GRID_COL_LENGTH","j","GRID_ROW_LENGTH","resetPath","resetGrid","currentRow","newNode","createNode","resetCss","document","getElementById","classList","remove","GreedyBestFirstHelper","path","shortestPathFromEnd","colorVisited","colorPath","helperAstar","helperDikjstras","element","contains","add","ANIMATION_SPEED","mouseStrat2","map","rowId","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","unshift","neighbors","filter","Fragment","href","onClick","toggleDiagonal","mapGrid","React","nodes","App","ref","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.49e68935.chunk.js","sourcesContent":["// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport \"./Node.css\";\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    };\r\n\r\n    render() {\r\n        const { startnode, endnode, col, row, isWall, onMouseUp, onMouseDown, onMouseEnter } = this.props;\r\n\r\n        let extraClassName = \"\";\r\n        if (startnode === true) extraClassName = \" startnode\";\r\n        if (endnode === true) extraClassName = \" endnode\"\r\n        if (isWall === true && endnode === false && startnode === false) extraClassName = \" node-wall\";\r\n        return <div\r\n            className={`Node ${extraClassName}`}\r\n            id={`node-${this.props.row}-${this.props.col}`}\r\n\r\n            onMouseDown={()=> onMouseDown(row, col)}\r\n            onMouseUp={()=> onMouseUp(row, col)}\r\n            onMouseEnter={()=> onMouseEnter(row, col)}\r\n        ></div>\r\n    }\r\n\r\n};\r\n","// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport getNewGridWithWallToggled from \"./PathfindingVisualizer\";\r\n\r\n// add user-select: none; to App.css; .App css to fix dragging out of div bug, trying to drag its text\r\n\r\n// current mouse coords\r\n// let mouseRow = 1;\r\n// let mouseCol = 1;\r\n// mouse coords at click\r\nlet originalNodeCol = null;\r\nlet originalNodeRow = null;\r\n// flags for which node is clicked\r\nlet mouseStartNode = false;\r\nlet mouseEndNode = false;\r\n\r\nlet drawingWalls = false;\r\n\r\nexport class GeneralStrat {\r\n\r\n    handleMouseDown(row, col) {\r\n        if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n            mouseStartNode = true;\r\n        } else if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n            mouseEndNode = true;\r\n        } else {\r\n            drawingWalls = true;\r\n            const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n            window.PathfindingVisualizer.setState({ grid: newGrid });\r\n        }\r\n        originalNodeCol = col;\r\n        originalNodeRow = row;\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n        console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n        if (drawingWalls) {\r\n            const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n            window.PathfindingVisualizer.setState({ grid: newGrid });\r\n        }\r\n\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if (mouseEndNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].endnode = false;\r\n            gred[row][col].endnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n        }\r\n        if (mouseStartNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].startnode = false;\r\n            gred[row][col].startnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n        }\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n        mouseEndNode = false;\r\n        mouseStartNode = false;\r\n        drawingWalls = false;\r\n    }\r\n\r\n}\r\n\r\nexport class StartEndStrat {\r\n    handleMouseDown(row, col) {\r\n        // console.log(originalNode);\r\n        if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n            mouseStartNode = true;\r\n            // console.log(mouseStartNode);\r\n        }\r\n        if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n            mouseEndNode = true;\r\n            // console.log(mouseStartNode);\r\n        }\r\n\r\n        originalNodeCol = col;\r\n        originalNodeRow = row;\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n        console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if (mouseEndNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].endnode = false;\r\n            gred[row][col].endnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n        }\r\n        if (mouseStartNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].startnode = false;\r\n            gred[row][col].startnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n        }\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n        mouseEndNode = false;\r\n        mouseStartNode = false;\r\n    }\r\n}\r\n\r\nexport class WallStrat {\r\n    handleMouseDown(row, col) {\r\n        const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n        window.PathfindingVisualizer.setState({ grid: newGrid, mouseLeftDown: true });\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n        const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n        window.PathfindingVisualizer.setState({ grid: newGrid });\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n    }\r\n}","import { getAllNodes, getUnvisitedNeighbors2, getUnvisitedNeighbors, getUnvisitedNeighborsDiag, sortNodesByDistance } from \"../PathfindingVisualizer\";\r\n\r\n\r\n\r\n// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\nexport function Dikjstras(grid, startNode, endNode) {\r\n    const visitedNodes = [];\r\n\r\n    // 1. Mark all nodes unvisited(already default) Create set of all unvisited\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    // console.log(unvisitedNodes);\r\n\r\n    // 2. Set initial node distance to 0, rest to infinity (already default)\r\n    startNode.distance = 0;\r\n\r\n    // !! = cast to boolean\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        // console.log(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n        // 3. Calculate distance of all unvisited neighbor nodes through currentNode\r\n        //    compare new distance with assigned distance, assign smaller distance.\r\n        updateNeighbors(grid, currentNode);\r\n        // 4. Mark currentNode visted, remove from unvisited set.\r\n        // unvisitedNodes.shift();\r\n        visitedNodes.push(currentNode);\r\n\r\n        // 5. if endNode is visited or smallest distance of unvisited nodes is infinite\r\n        //    stop algo\r\n        // 6. select unvisited node with lowest distance, set to current node\r\n        //    loop back to step 3\r\n        // console.log(grid);\r\n    }\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode) {\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    // const unvisitedNeighbors = getUnvisitedNeighbors2(grid, currentNode);\\\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let nei = neighbor.distance;\r\n        let cur = currentNode.distance + 1;\r\n        neighbor.distance = nei > cur ? cur: nei;\r\n        // neighbor.distance = currentNode.distance + 1; //neighbor dist always greater\r\n        if (neighbor.previousNode == null) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    if(window.PathfindingVisualizer.diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let nei = neighbor.distance;\r\n            let cur = currentNode.distance + 1.4;\r\n            neighbor.distance = nei > cur ? cur: nei;\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","\r\n\r\nexport function Manhattan(node) {\r\n    // console.log('start manhattan');\r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    // console.log(window.PathfindingVisualizer.state.END_NODE_COL)\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    // console.log(dy);\r\n    return (dx + dy);\r\n}\r\n\r\nexport function Octile(node, weight) {\r\n    \r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    return (weight * (Math.sqrt(dx + dy)));\r\n}","import { getAllNodes, sortNodesByDistance, sortNodesByDistanceThenHcost } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\n\r\n// Gcost = distance from starting node\r\n// Hcost (heuristic) = distance from end node\r\n// Fcost = Gcost + Hcost (using distance var)\r\n\r\n\r\nexport function Astar(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    startNode.distance = 0;\r\n    startNode.Gcost = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistanceThenHcost(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode, diagonalPathing);\r\n\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\n\r\nfunction updateNeighbors(grid, currentNode, diagonalPathing) {\r\n    // console.log('astar updateneighbors');\r\n\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let curG = currentNode.Gcost + 1;\r\n        // let neiG = neighbor.Gcost;\r\n        // neighbor.Gcost = neiG > curG ? curG : neiG;\r\n        let curH = 0;\r\n        if (diagonalPathing) {\r\n            curH = Octile(neighbor, 5);\r\n        } else {\r\n            curH = Manhattan(neighbor);\r\n        }\r\n        // curH = Manhattan(neighbor);\r\n        if (curG + curH < neighbor.distance) {\r\n            neighbor.distance = Math.round(curG + curH);\r\n            neighbor.previousNode = currentNode;\r\n            neighbor.Hcost = curH;\r\n            neighbor.Gcost = curG;\r\n        }\r\n    }\r\n\r\n    if (diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let curG = currentNode.Gcost + 1.4;\r\n            let curH = Octile(neighbor, 5);\r\n            neighbor.Hcost = curH;\r\n            // let curH = Manhattan(neighbor);\r\n            if (curG + curH < neighbor.distance) {\r\n                if(neighbor.Gcost > curG)neighbor.Gcost = curG;\r\n                let dist = Math.round(curG + curH);\r\n                if(dist < neighbor.distance) {\r\n                neighbor.distance = dist\r\n                neighbor.previousNode = currentNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}","import { getAllNodes } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\n\r\nexport function GreedyBestFirst(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    // console.log(unvisitedNodes);\r\n    startNode.distance = 0;\r\n    startNode.Hcost = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n\r\n        sortNodesByHcost(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.Hcost === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode, diagonalPathing);\r\n\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\n\r\nfunction updateNeighbors(grid, currentNode, diagonalPathing) {\r\n    console.log('GBFS updateneighbors');\r\n\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let h = Manhattan(neighbor);\r\n        if (h < neighbor.Hcost) {\r\n            neighbor.Hcost = h;\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n\r\n    }\r\n\r\n    if (diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let h = Manhattan(neighbor);\r\n            if (h < neighbor.Hcost) {\r\n                neighbor.Hcost = h;\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\n\r\nexport function sortNodesByHcost(unvisitedNodes) {\r\n    // console.log('GBFS sortbyH');\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.Hcost - nodeB.Hcost);\r\n}","import React from \"react\";\r\nimport Node from \"./Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { setTimeout } from 'timers';\r\nimport { StartEndStrat, WallStrat, GeneralStrat } from \"./MouseStrat\";\r\nimport { Dikjstras } from \"./Algorithms/Dikjstras\";\r\nimport { Astar } from \"./Algorithms/Astar\"\r\nimport { GreedyBestFirst } from \"./Algorithms/GreedyBestFirst\"\r\n\r\nconst ANIMATION_SPEED = 100;\r\n\r\nconst sleep = (ms) => {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n};\r\n\r\n// React uses JSX not plain javascript, first letter of tag indicates elements. \r\n// Uppercase used to specify react components; ie cant camelCase.\r\nexport default class PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            grid: [],\r\n            mouseLeftDown: false,\r\n            GRID_ROW_LENGTH: 45,\r\n            GRID_COL_LENGTH: 25,\r\n\r\n            START_NODE_ROW: 10,\r\n            START_NODE_COL: 7,\r\n            END_NODE_ROW: 10,\r\n            END_NODE_COL: 30,\r\n        };\r\n        const diagonalPathing = false;\r\n        const mouseStrat2 = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetGrid();\r\n        this.mouseStrat2 = new GeneralStrat();\r\n        this.diagonalPathing = false;\r\n    }\r\n\r\n    createNode(row, col) {\r\n        return {\r\n            Gcost: Infinity,\r\n            Hcost: Infinity,\r\n            distance: Infinity,\r\n            isVisited: false,\r\n            row: row,\r\n            col: col,\r\n            startnode: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            endnode: row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL,\r\n            isWall: false,\r\n            previousNode: null,\r\n        }\r\n    }\r\n\r\n    resetWall = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].isWall = false;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetPath = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].previousNode = null;\r\n                grid[i][j].distance = Infinity;\r\n                grid[i][j].isVisited = false;\r\n                grid[i][j].Gcost = Infinity;\r\n                grid[i][j].Hcost = Infinity;\r\n\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetGrid = async () => {\r\n        const grid = [];\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            let currentRow = [];\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                const newNode = this.createNode(i, j)\r\n                currentRow.push(newNode);\r\n            }\r\n            grid.push(currentRow);\r\n        }\r\n        this.setState({ grid });\r\n        return;\r\n    }\r\n\r\n    resetCss = async () => {\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                let node = document.getElementById(`node-${i}-${j}`);\r\n\r\n                //these classes not set by Node.js, not in state grid so manual remove, only for animation\r\n                node.classList.remove(\"node-visited\");\r\n                node.classList.remove(\"node-path\");\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    mapGrid() {\r\n        const { grid } = this.state;\r\n        return grid.map((row, rowId) => {\r\n            return (\r\n                <div key={rowId}>\r\n                    {row.map((node, nodeId) => {\r\n                        let { startnode, endnode, isWall, } = node;\r\n                        return <Node\r\n                            key={nodeId}\r\n                            row={rowId}\r\n                            col={nodeId}\r\n                            startnode={startnode}\r\n                            endnode={endnode}\r\n                            // distance={distance}\r\n                            // isVisited={isVisited}\r\n                            isWall={isWall}\r\n                            // previousNode={previousNode}  \r\n                            // onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseEnter={(row, col) => this.mouseStrat2.handleMouseEnter(row, col)}\r\n                            onMouseUp={(row, col) => this.mouseStrat2.handleMouseUp(row, col)}\r\n\r\n                        ></Node>\r\n                    })}\r\n                </div>\r\n            )\r\n        })\r\n    }\r\n\r\n    GreedyBestFirstHelper = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = GreedyBestFirst(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperAstar = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Astar(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperDikjstras = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Dikjstras(grid, startnode, endnode);\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    colorVisited = async (visitedNodes) => {\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            const node = visitedNodes[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-visited\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.1);\r\n        }\r\n        return;\r\n    }\r\n\r\n    colorPath = async (path) => {\r\n        for (let i = 0; i < path.length; i++) {\r\n            const node = path[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-path\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.5);\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Follows previousNode property from endNode to startNode.\r\n    // Must be called AFTER pathfinding algo\r\n    shortestPathFromEnd(startNode, endNode) {\r\n        const path = [];\r\n        let currentNode = endNode\r\n        while (currentNode != null) {\r\n            // console.log(currentNode);\r\n            path.unshift(currentNode);\r\n            currentNode = currentNode.previousNode;\r\n        }\r\n        return path;\r\n    }\r\n\r\n    getNewGridWithWallToggled(grid, row, col) {\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    };\r\n\r\n\r\n    toggleDiagonal() {\r\n        this.diagonalPathing = !this.diagonalPathing;\r\n        // let but = document.getElementById(\"togglebutton\");\r\n        // but.classList.toggleClass(\"foo\");\r\n\r\n        console.log(this.diagonalPathing);\r\n    }\r\n\r\n    // return array of unvisited neighbors of node\r\n    // does not include diagonal\r\n    getUnvisitedNeighbors(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    // also need checks to allow / disallow diagonal pathing through corners\r\n    getUnvisitedNeighborsDiag(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (this.diagonalPathing) {\r\n            // ⬉\r\n            if (row > 0 && col > 0) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row - 1][col - 1]);\r\n            }\r\n            // ⬈\r\n            if (row > 0 && col < grid[0].length - 1) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row - 1][col + 1]);\r\n            }\r\n            // ⬊\r\n            if (row < grid.length - 1 && col < grid[0].length - 1) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row + 1][col + 1]);\r\n            }\r\n            // ⬋\r\n            if (row < grid.length - 1 && col > 0) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row + 1][col - 1]);\r\n            }\r\n        }\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    render() {\r\n        // const { grid } = this.state;\r\n        return (\r\n            <React.Fragment>\r\n                <div className=\"button-bar\">\r\n                    <a href=\"http://patgiok.azurewebsites.net/\"><button>Home</button></a>\r\n                    {/* <button onClick={() => console.log(this.state.grid)}> check grid</button> */}\r\n                    <button onClick={() => this.resetGrid()}>reset grid</button>\r\n                    <button onClick={() => this.resetWall()}>reset walls</button>\r\n                    <button onClick={() => this.GreedyBestFirstHelper()}>BestFirst</button>\r\n                    <button onClick={() => this.helperAstar()}>Astar</button>\r\n                    <button onClick={() => this.helperDikjstras()}>Dikjstras</button>\r\n                    <button id=\"togglebutton\" onClick={() => this.toggleDiagonal()}>diagonals</button>\r\n                    {/* <button onClick={() => this.mouseStrat2 = new StartEndStrat(this)}>startendstrat</button>\r\n                    <button onClick={() => this.mouseStrat2 = new WallStrat(this)}>wallstrat</button> */}\r\n                </div>\r\n                <div className=\"grid-container\">\r\n                    {this.mapGrid()}\r\n                </div>\r\n            </React.Fragment>\r\n        );\r\n    }\r\n}\r\n\r\n//return array of all nodes in 1d array\r\nexport function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// sorts input array of nodes by their distance\r\nexport function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n// if both distance equal, first condition is 0 and considered false, then second part of condition is executed.\r\nexport function sortNodesByDistanceThenHcost(unvisitedNodes) {\r\n    unvisitedNodes.sort(function (nodeA, nodeB) {\r\n        return nodeA.distance - nodeB.distance || nodeA.Hcost - nodeB.Hcost\r\n    })\r\n}\r\n\r\n\r\n// takes too long, has to check every node\r\n// export function getUnvisitedNeighbors3(nodes, currentNode) {\r\n//     console.log('getUnvisitedNeighbors3');\r\n//     console.log(nodes);\r\n//     // console.log(currentNode);\r\n//     const { row, col, } = currentNode;\r\n//     let neighbors = [];\r\n//     neighbors = nodes.filter(\r\n//         function (node) {\r\n//             return !node.isVisited && dist(node, row, col) == 1.0\r\n\r\n//             // return !node.isVisited && dist(node, row, col) == 1.4\r\n//         })\r\n//     console.log(neighbors);\r\n//     return neighbors;\r\n// }\r\n// function dist(n, r, c) {\r\n//     let num = Math.sqrt(Math.pow(n.row - r, 2) + Math.pow(n.col - c, 2))\r\n//     num = num.toFixed(1);\r\n//     console.log(num);\r\n//     return num;\r\n// }","import './App.css';\r\nimport React from 'react';\r\nimport PathfindingVisualizer from \"./pathfindingvisualizer/PathfindingVisualizer\";\r\n// import ReactDOM from 'react-dom';\r\n\r\nfunction App() {\r\n  // const GlobalGrid = React.createContext([]);\r\n  // ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />, document.getElementById(\"App\"));\r\n  return (\r\n    \r\n    <div className=\"App\">\r\n      <PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />\r\n      {/* <PathfindingVisualizer /> */}\r\n      \r\n    </div>\r\n  );\r\n}\r\n\r\n// ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}}/>, document.getElementById(\"App\"))\r\n// ReactDOM.render(<Page ref={(ourComponent) => {window.ourComponent = ourComponent}} />, document.getElementById(\"app\"));\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}