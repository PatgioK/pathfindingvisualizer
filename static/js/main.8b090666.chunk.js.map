{"version":3,"sources":["pathfindingvisualizer/Node.js","pathfindingvisualizer/MouseStrat.js","pathfindingvisualizer/Algorithms/Dikjstras.js","pathfindingvisualizer/Heuristics.js","pathfindingvisualizer/Algorithms/Astar.js","pathfindingvisualizer/heap.js","pathfindingvisualizer/Algorithms/GreedyBestFirst.js","pathfindingvisualizer/Algorithms/BFS.js","pathfindingvisualizer/components/AlgoExplaination.js","pathfindingvisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","startnode","endnode","col","row","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","className","id","Component","originalNodeCol","originalNodeRow","mouseStartNode","mouseEndNode","drawingWalls","GeneralStrat","window","PathfindingVisualizer","grid","newGrid","getNewGridWithWallToggled","setState","mouseLeftDown","gred","slice","END_NODE_COL","END_NODE_ROW","START_NODE_COL","START_NODE_ROW","Dikjstras","startNode","endNode","visitedNodes","unvisitedNodes","getAllNodes","distance","length","console","log","sortNodesByDistance","currentNode","shift","Infinity","isVisited","updateNeighbors","push","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","nei","cur","previousNode","diagonalPathing","unvisitedNeighborsDiag","getUnvisitedNeighborsDiag","sort","nodeA","nodeB","Manhattan","node","Math","abs","Octile","weight","dx","dy","sqrt","Astar","Gcost","sortNodesByDistanceThenHcost","curG","curH","round","Hcost","dist","buildMinHeap","array","index","floor","minHeapify","arrLength","smallest","left","right","swap","heapUnshift","toRemove","pop","arr","leftIdx","rightIdx","temp","GreedyBestFirst","h","isOpen","BFS","openList","AlgoExplaination","useState","text","setText","name","setName","useEffect","algoName","sleep","ms","Promise","resolve","setTimeout","resetWall","a","i","GRID_COL_LENGTH","j","GRID_ROW_LENGTH","resetPath","resetGrid","currentRow","newNode","createNode","resetCss","document","getElementById","classList","remove","colorVisited","element","contains","add","ANIMATION_SPEED","colorPath","path","GreedyBestFirstHelper","shortestPathFromEnd","helperAstar","helperDikjstras","helperBFS","AlgoDef","mouseStrat2","unshift","neighbors","filter","map","rowId","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","Fragment","href","onMouseOver","onClick","toggleDiagonal","mapGrid","but","style","backgroundColor","React","nodes","App","ref","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.8b090666.chunk.js","sourcesContent":["// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport \"./Node.css\";\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    };\r\n\r\n    render() {\r\n        const { startnode, endnode, col, row, isWall, onMouseUp, onMouseDown, onMouseEnter } = this.props;\r\n\r\n        let extraClassName = \"\";\r\n        if (startnode === true) extraClassName = \" startnode\";\r\n        if (endnode === true) extraClassName = \" endnode\"\r\n        if (isWall === true && endnode === false && startnode === false) extraClassName = \" node-wall\";\r\n        return <div\r\n            className={`Node ${extraClassName}`}\r\n            id={`node-${this.props.row}-${this.props.col}`}\r\n\r\n            onMouseDown={()=> onMouseDown(row, col)}\r\n            onMouseUp={()=> onMouseUp(row, col)}\r\n            onMouseEnter={()=> onMouseEnter(row, col)}\r\n        ></div>\r\n    }\r\n\r\n};\r\n","// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport getNewGridWithWallToggled from \"./PathfindingVisualizer\";\r\n\r\n// add user-select: none; to App.css; .App css to fix dragging out of div bug, trying to drag its text\r\n\r\n// current mouse coords\r\n// let mouseRow = 1;\r\n// let mouseCol = 1;\r\n// mouse coords at click\r\nlet originalNodeCol = null;\r\nlet originalNodeRow = null;\r\n// flags for which node is clicked\r\nlet mouseStartNode = false;\r\nlet mouseEndNode = false;\r\n\r\nlet drawingWalls = false;\r\n\r\nexport class GeneralStrat {\r\n\r\n    handleMouseDown(row, col) {\r\n        if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n            mouseStartNode = true;\r\n        } else if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n            mouseEndNode = true;\r\n        } else {\r\n            drawingWalls = true;\r\n            const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n            window.PathfindingVisualizer.setState({ grid: newGrid });\r\n        }\r\n        originalNodeCol = col;\r\n        originalNodeRow = row;\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n        // console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n        if (drawingWalls) {\r\n            const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n            window.PathfindingVisualizer.setState({ grid: newGrid });\r\n        }\r\n\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if (mouseEndNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].endnode = false;\r\n            gred[row][col].endnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n        }\r\n        if (mouseStartNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].startnode = false;\r\n            gred[row][col].startnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n        }\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n        mouseEndNode = false;\r\n        mouseStartNode = false;\r\n        drawingWalls = false;\r\n    }\r\n\r\n}\r\n\r\n// export class StartEndStrat {\r\n//     handleMouseDown(row, col) {\r\n//         // console.log(originalNode);\r\n//         if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n//             mouseStartNode = true;\r\n//             // console.log(mouseStartNode);\r\n//         }\r\n//         if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n//             mouseEndNode = true;\r\n//             // console.log(mouseStartNode);\r\n//         }\r\n\r\n//         originalNodeCol = col;\r\n//         originalNodeRow = row;\r\n//         window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n//         console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n//     }\r\n\r\n//     handleMouseEnter(row, col) {\r\n\r\n//     }\r\n\r\n//     handleMouseUp(row, col) {\r\n//         if (mouseEndNode) {\r\n//             const gred = window.PathfindingVisualizer.state.grid.slice();\r\n//             gred[originalNodeRow][originalNodeCol].endnode = false;\r\n//             gred[row][col].endnode = true;\r\n//             window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n//         }\r\n//         if (mouseStartNode) {\r\n//             const gred = window.PathfindingVisualizer.state.grid.slice();\r\n//             gred[originalNodeRow][originalNodeCol].startnode = false;\r\n//             gred[row][col].startnode = true;\r\n//             window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n//         }\r\n//         window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n//         mouseEndNode = false;\r\n//         mouseStartNode = false;\r\n//     }\r\n// }\r\n\r\n// export class WallStrat {\r\n//     handleMouseDown(row, col) {\r\n//         const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n//         window.PathfindingVisualizer.setState({ grid: newGrid, mouseLeftDown: true });\r\n//     }\r\n\r\n//     handleMouseEnter(row, col) {\r\n//         if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n//         const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n//         window.PathfindingVisualizer.setState({ grid: newGrid });\r\n//     }\r\n\r\n//     handleMouseUp(row, col) {\r\n//         window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n//     }\r\n// }","import { getAllNodes, } from \"../PathfindingVisualizer\";\r\n\r\n\r\n\r\n// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\nexport function Dikjstras(grid, startNode, endNode) {\r\n    const visitedNodes = [];\r\n\r\n    // 1. Mark all nodes unvisited(already default) Create set of all unvisited\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    // console.log(unvisitedNodes);\r\n\r\n    // 2. Set initial node distance to 0, rest to infinity (already default)\r\n    startNode.distance = 0;\r\n\r\n    // !! = cast to boolean\r\n    while (!!unvisitedNodes.length) {\r\n        console.log(\"dijkstra\");\r\n        sortNodesByDistance(unvisitedNodes);\r\n        // console.log(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n        // 3. Calculate distance of all unvisited neighbor nodes through currentNode\r\n        //    compare new distance with assigned distance, assign smaller distance.\r\n        updateNeighbors(grid, currentNode);\r\n        // 4. Mark currentNode visted, remove from unvisited set.\r\n        // unvisitedNodes.shift();\r\n        visitedNodes.push(currentNode);\r\n\r\n        // 5. if endNode is visited or smallest distance of unvisited nodes is infinite\r\n        //    stop algo\r\n        // 6. select unvisited node with lowest distance, set to current node\r\n        //    loop back to step 3\r\n        // console.log(grid);\r\n    }\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode) {\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    // const unvisitedNeighbors = getUnvisitedNeighbors2(grid, currentNode);\\\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let nei = neighbor.distance;\r\n        let cur = currentNode.distance + 1;\r\n        neighbor.distance = nei > cur ? cur: nei;\r\n        // neighbor.distance = currentNode.distance + 1; //neighbor dist always greater\r\n        if (neighbor.previousNode == null) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    if(window.PathfindingVisualizer.diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let nei = neighbor.distance;\r\n            let cur = currentNode.distance + 1.4;\r\n            neighbor.distance = nei > cur ? cur: nei;\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// sorts input array of nodes by their distance\r\nexport function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n","\r\n\r\nexport function Manhattan(node) {\r\n    // console.log('start manhattan');\r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    // console.log(dy);\r\n    return (dx + dy);\r\n}\r\n\r\nexport function Octile(node, weight) {\r\n    \r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    return (weight * (Math.sqrt(dx + dy)));\r\n}","import { getAllNodes } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\n\r\n// Gcost = distance from starting node\r\n// Hcost (heuristic) = distance from end node\r\n// Fcost = Gcost + Hcost (using distance var)\r\n\r\n\r\nexport function Astar(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    startNode.distance = 0;\r\n    startNode.Gcost = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistanceThenHcost(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode, diagonalPathing);\r\n\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\n\r\nfunction updateNeighbors(grid, currentNode, diagonalPathing) {\r\n    // console.log('astar updateneighbors');\r\n\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let curG = currentNode.Gcost + 1;\r\n        // let neiG = neighbor.Gcost;\r\n        // neighbor.Gcost = neiG > curG ? curG : neiG;\r\n        let curH = 0;\r\n        if (diagonalPathing) {\r\n            curH = Octile(neighbor, 5);\r\n        } else {\r\n            curH = Manhattan(neighbor);\r\n        }\r\n        // curH = Manhattan(neighbor);\r\n        if (curG + curH < neighbor.distance) {\r\n            neighbor.distance = Math.round(curG + curH);\r\n            neighbor.previousNode = currentNode;\r\n            neighbor.Hcost = curH;\r\n            neighbor.Gcost = curG;\r\n        }\r\n    }\r\n\r\n    if (diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let curG = currentNode.Gcost + 1.4;\r\n            let curH = Octile(neighbor, 5);\r\n            neighbor.Hcost = curH;\r\n            // let curH = Manhattan(neighbor);\r\n            if (curG + curH < neighbor.distance) {\r\n                if (neighbor.Gcost > curG) neighbor.Gcost = curG;\r\n                let dist = Math.round(curG + curH);\r\n                if (dist < neighbor.distance) {\r\n                    neighbor.distance = dist\r\n                    neighbor.previousNode = currentNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n// if both distance equal, first condition is 0 and considered false, then second part of condition is executed.\r\nexport function sortNodesByDistanceThenHcost(unvisitedNodes) {\r\n    unvisitedNodes.sort(function (nodeA, nodeB) {\r\n        return nodeA.distance - nodeB.distance || nodeA.Hcost - nodeB.Hcost\r\n    })\r\n}","\r\nexport function buildMinHeap(array) {\r\n    var index = Math.floor(array.length / 2) - 1;\r\n    while (index >= 0) {\r\n        minHeapify(array, index, array.length);\r\n        index--;\r\n    }\r\n}\r\n\r\nfunction minHeapify(array, index, arrLength) {\r\n    var smallest = index;\r\n    var left = index * 2 + 1;\r\n    var right = index * 2 + 2;\r\n\r\n    // console.log(array[left]);\r\n    if (left < arrLength && array[left].distance < array[smallest].distance)\r\n        smallest = left;\r\n    if (right < arrLength && array[right].distance < array[smallest].distance)\r\n        smallest = right;\r\n\r\n    if (smallest != index) {\r\n        swap(array, index, smallest);\r\n\r\n        if (smallest * 2 + 2 > arrLength) {\r\n            return;\r\n        }\r\n        minHeapify(array, smallest, arrLength);\r\n    }\r\n}\r\n\r\nexport function heapUnshift(array) {\r\n    console.log(`heap unshift arr length:` + array.length);\r\n    var length = array.length - 1;\r\n    swap(array, 0, length);\r\n    var toRemove = array.pop();\r\n    buildMinHeap(array);\r\n    console.log(`heap unshift arr length:` + array.length);\r\n    return toRemove;\r\n\r\n}\r\n\r\nfunction swap(arr, leftIdx, rightIdx) {\r\n    // console.log('swapper  left:' + leftIdx + ' right:' + rightIdx);\r\n    var temp = arr[leftIdx];\r\n    arr[leftIdx] = arr[rightIdx];\r\n    arr[rightIdx] = temp;\r\n}\r\n","import { getAllNodes } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\nimport { buildMinHeap, heapUnshift } from \"../heap\";\r\n\r\n// using var node.distance for node.hcost to reuse heap functions.\r\nexport function GreedyBestFirst(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    buildMinHeap(unvisitedNodes);\r\n    startNode.distance = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        buildMinHeap(unvisitedNodes);\r\n        const currentNode = heapUnshift(unvisitedNodes);\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode, diagonalPathing);\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, diagonalPathing) {\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let h = 0\r\n        if (!neighbor.isOpen) \r\n            neighbor.isOpen = true;\r\n        \r\n        if (!diagonalPathing)\r\n            h = Manhattan(neighbor);\r\n        else\r\n            h = Octile(neighbor, 1);\r\n\r\n        if (h < neighbor.distance) {\r\n            neighbor.distance = h;\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    if (diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let h = 0\r\n            if (!neighbor.isOpen) {\r\n                neighbor.isOpen = true;\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n            h = Octile(neighbor, 1)\r\n\r\n            if (h < neighbor.distance) {\r\n                neighbor.distance = h;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\nexport function sortNodesByHcost(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.Hcost - nodeB.Hcost);\r\n}","export function BFS(grid, startNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const openList = [];\r\n    openList.push(startNode);\r\n\r\n    while (!!openList.length) {\r\n        const currentNode = openList.shift();\r\n        visitedNodes.push(currentNode);\r\n        if (currentNode.endnode) break;\r\n        if (currentNode.isWall) continue;\r\n\r\n        const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n        // console.log(unvisitedNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            if(neighbor.isWall) continue;\r\n            openList.push(neighbor);\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n            neighbor.isVisited = true;\r\n        }\r\n\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            if(neighbor.isWall) continue;\r\n            openList.push(neighbor);\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n            neighbor.isVisited = true;\r\n        }\r\n    }\r\n    startNode.previousNode = null;\r\n    return visitedNodes;\r\n\r\n}","import React, { useState, useEffect } from 'react';\r\nimport \"./AlgoExplaination.css\";\r\n\r\nexport default function AlgoExplaination(props) {\r\n    const [text, setText] = useState(\"default\");\r\n    const [name, setName] = useState(\"def\");\r\n    // let algoProp = this.props.algoDef;\r\n    useEffect(() => {\r\n        switch (props.algoName) {\r\n            case \"Home\":\r\n                setName(\"\");\r\n                setText(\"My website for links my other projects!\");\r\n                break;\r\n            case \"path\":\r\n                setName(\"\");\r\n                setText(\"A pathfinding visualizer built with React! Click and drag to move the start or end nodes. Click on nodes to toggle walls!\");\r\n                break;\r\n            case \"Dikj\":\r\n                setText(\"Considered the father of pathfinding algorithms. Explores nodes based on distance from the start. Guarantees a shortest path\");\r\n                setName(\"Dikjstra's Algorithm: \");\r\n                break;\r\n            case \"Astar\":\r\n                setText(\"A variant of Dikjstra's Algorithm. Uses a heuristic function to determine which node to explore next. The optimization results in shortests paths being found more quickly. Guarantees a shortest path\");\r\n                setName(\"A*: \");\r\n                break;\r\n            case \"BestFirst\":\r\n                setText(\"An algorithm that explores nodes based on its distance from the target node. does NOT guarantee a shortest path\");\r\n                setName(\"Best First: \");\r\n                break;\r\n            case \"BFS\":\r\n                setText(\"Uses a queue data structure to explore nodes. Guarantees a shortest path\");\r\n                setName(\"Breadth First: \");\r\n                break;\r\n            case \"diag\":\r\n                setText(\"Toggle to allow diagonal pathing\");\r\n                setName(\"\");\r\n                break;\r\n            default:\r\n                setName(\"\");\r\n                setText(\"A pathfinding visualizer built with React! Click and drag to move the start or end nodes. Click on nodes to toggle walls!\");\r\n        }\r\n    });\r\n\r\n    return (\r\n        <div className=\"algoExp\"><span className=\"algoExpName\">{name}</span>{text}</div>\r\n    )\r\n}","import React from \"react\";\r\nimport Node from \"./Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { setTimeout } from 'timers';\r\nimport { GeneralStrat } from \"./MouseStrat\";\r\n// import { StartEndStrat, WallStrat, } from \"./MouseStrat\";\r\nimport { Dikjstras } from \"./Algorithms/Dikjstras\";\r\nimport { Astar } from \"./Algorithms/Astar\"\r\nimport { GreedyBestFirst } from \"./Algorithms/GreedyBestFirst\"\r\nimport { BFS } from \"./Algorithms/BFS\"\r\nimport AlgoExplaination from \"./components/AlgoExplaination\"\r\n\r\nconst ANIMATION_SPEED = 100;\r\n\r\nconst sleep = (ms) => {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n};\r\n\r\n// React uses JSX not plain javascript, first letter of tag indicates elements. \r\n// Uppercase used to specify react components; ie cant camelCase.\r\nexport default class PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            grid: [],\r\n            mouseLeftDown: false,\r\n            GRID_ROW_LENGTH: 40,\r\n            GRID_COL_LENGTH: 20,\r\n\r\n            START_NODE_ROW: 10,\r\n            START_NODE_COL: 7,\r\n            END_NODE_ROW: 10,\r\n            END_NODE_COL: 30,\r\n            AlgoDef: null,\r\n        };\r\n        const diagonalPathing = false;\r\n        const mouseStrat2 = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetGrid();\r\n        this.mouseStrat2 = new GeneralStrat();\r\n        this.diagonalPathing = false;\r\n        this.AlgoDef = null;\r\n    }\r\n\r\n    createNode(row, col) {\r\n        return {\r\n            previousNode: null,\r\n            row: row,\r\n            col: col,\r\n            Gcost: Infinity,\r\n            Hcost: Infinity,\r\n            distance: Infinity,\r\n            isOpen: false,\r\n            isVisited: false,\r\n            startnode: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            endnode: row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL,\r\n            isWall: false,\r\n        }\r\n    }\r\n\r\n    resetWall = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].isWall = false;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetPath = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].previousNode = null;\r\n                grid[i][j].distance = Infinity;\r\n                grid[i][j].isVisited = false;\r\n                grid[i][j].Gcost = Infinity;\r\n                grid[i][j].Hcost = Infinity;\r\n                grid[i][j].isOpen = false;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetGrid = async () => {\r\n        const grid = [];\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            let currentRow = [];\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                const newNode = this.createNode(i, j)\r\n                currentRow.push(newNode);\r\n            }\r\n            grid.push(currentRow);\r\n        }\r\n        this.setState({ grid });\r\n        return;\r\n    }\r\n\r\n    resetCss = async () => {\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                let node = document.getElementById(`node-${i}-${j}`);\r\n\r\n                //these classes not set by Node.js, not in state grid so manual remove, only for animation\r\n                node.classList.remove(\"node-visited\");\r\n                node.classList.remove(\"node-path\");\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n\r\n    colorVisited = async (visitedNodes) => {\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            const node = visitedNodes[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-visited\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.1);\r\n        }\r\n        return;\r\n    }\r\n\r\n    colorPath = async (path) => {\r\n        for (let i = 0; i < path.length; i++) {\r\n            const node = path[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-path\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.5);\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Follows previousNode property from endNode to startNode.\r\n    // Must be called AFTER pathfinding algo\r\n    shortestPathFromEnd(startNode, endNode) {\r\n        const path = [];\r\n        let currentNode = endNode\r\n        while (currentNode != null) {\r\n            // console.log(currentNode);\r\n            path.unshift(currentNode);\r\n            currentNode = currentNode.previousNode;\r\n        }\r\n        return path;\r\n    }\r\n\r\n    // Changes grid, find better complexity\r\n    getNewGridWithWallToggled(grid, row, col) {\r\n        const newGrid = grid.slice();      // bad slicing every time mouse goes in new node\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    };\r\n\r\n\r\n    // return array of unvisited neighbors of node\r\n    // does not include diagonal\r\n    getUnvisitedNeighbors(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    // also need checks to allow / disallow diagonal pathing through corners\r\n    getUnvisitedNeighborsDiag(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (this.diagonalPathing) {\r\n            // ⬉\r\n            if (row > 0 && col > 0) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row - 1][col - 1]);\r\n            }\r\n            // ⬈\r\n            if (row > 0 && col < grid[0].length - 1) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row - 1][col + 1]);\r\n            }\r\n            // ⬊\r\n            if (row < grid.length - 1 && col < grid[0].length - 1) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row + 1][col + 1]);\r\n            }\r\n            // ⬋\r\n            if (row < grid.length - 1 && col > 0) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row + 1][col - 1]);\r\n            }\r\n        }\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    mapGrid() {\r\n        const { grid } = this.state;\r\n        return grid.map((row, rowId) => {\r\n            return (\r\n                <div key={rowId}>\r\n                    {row.map((node, nodeId) => {\r\n                        let { startnode, endnode, isWall, } = node;\r\n                        return <Node\r\n                            key={nodeId}\r\n                            row={rowId}\r\n                            col={nodeId}\r\n                            startnode={startnode}\r\n                            endnode={endnode}\r\n                            // distance={distance}\r\n                            // isVisited={isVisited}\r\n                            isWall={isWall}\r\n                            // previousNode={previousNode}  \r\n                            // onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseEnter={(row, col) => this.mouseStrat2.handleMouseEnter(row, col)}\r\n                            onMouseUp={(row, col) => this.mouseStrat2.handleMouseUp(row, col)}\r\n\r\n                        ></Node>\r\n                    })}\r\n                </div>\r\n            )\r\n        })\r\n    }\r\n\r\n    render() {\r\n        // const { grid } = this.state;\r\n        // React.Fragment lets me return multiple non nested divs\r\n        return (\r\n            <React.Fragment>\r\n                <div className=\"button-bar\">\r\n                    <a href=\"http://patgiok.azurewebsites.net/\"><button\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"Home\" })}\r\n                        >Home</button></a>\r\n                    {/* <button onClick={() => console.log(this.state.grid)}> check grid</button> */}\r\n                    {/* <button onClick={() => console.log(this.state.AlgoDef)}> check state</button> */}\r\n                    <button onClick={() => this.resetCss()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"path\" })}\r\n                    >Reset Path</button>\r\n                    {/* <button onClick={() => this.resetGrid()}>reset grid</button> */}\r\n                    <button onClick={() => this.resetWall()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"path\" })}\r\n                    >Reset Walls</button>\r\n\r\n                    <button\r\n                        onClick={() => this.helperDikjstras()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"Dikj\" })}\r\n                    >Dikjstra</button>\r\n\r\n                    <button\r\n                        onClick={() => this.helperAstar()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"Astar\" })}\r\n                    >A*</button>\r\n\r\n                    <button\r\n                        onClick={() => this.GreedyBestFirstHelper()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"BestFirst\" })}\r\n                    >Best First</button>\r\n\r\n                    <button\r\n                        onClick={() => this.helperBFS()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"BFS\" })}\r\n                    >Breadth First</button>\r\n\r\n                    <button id=\"togglebutton\"\r\n                        onClick={() => this.toggleDiagonal()}\r\n                        onMouseOver={() => this.setState({ AlgoDef: \"diag\" })}\r\n                    >Allow Diagonal</button>\r\n                    {/* <button onClick={() => this.mouseStrat2 = new StartEndStrat(this)}>startendstrat</button>\r\n                    <button onClick={() => this.mouseStrat2 = new WallStrat(this)}>wallstrat</button> */}\r\n                </div>\r\n                <div className=\"grid-container\">\r\n                    {this.mapGrid()}\r\n                </div>\r\n                <div>\r\n                    <AlgoExplaination algoName={this.state.AlgoDef} />\r\n                </div>\r\n            </React.Fragment>\r\n        );\r\n    }\r\n    toggleDiagonal() {\r\n        this.diagonalPathing = !this.diagonalPathing;\r\n        let d = \"diag\"\r\n        var but = document.getElementById(\"togglebutton\");\r\n        if (this.diagonalPathing) {\r\n            but.style.backgroundColor = \"#2d73ff\";\r\n        } else {\r\n            but.style.backgroundColor = \"#222570\";\r\n        }\r\n        console.log(`diagonal pathing: ${this.diagonalPathing}`);\r\n    }\r\n\r\n    GreedyBestFirstHelper = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = GreedyBestFirst(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperAstar = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Astar(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperDikjstras = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Dikjstras(grid, startnode, endnode);\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperBFS = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = BFS(grid, startnode, this.diagonalPathing);\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n}\r\n\r\n//return array of all nodes in 1d array\r\nexport function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// takes too long, has to check every node\r\n// export function getUnvisitedNeighbors3(nodes, currentNode) {\r\n//     console.log('getUnvisitedNeighbors3');\r\n//     console.log(nodes);\r\n//     // console.log(currentNode);\r\n//     const { row, col, } = currentNode;\r\n//     let neighbors = [];\r\n//     neighbors = nodes.filter(\r\n//         function (node) {\r\n//             return !node.isVisited && dist(node, row, col) == 1.0\r\n\r\n//             // return !node.isVisited && dist(node, row, col) == 1.4\r\n//         })\r\n//     console.log(neighbors);\r\n//     return neighbors;\r\n// }\r\n// function dist(n, r, c) {\r\n//     let num = Math.sqrt(Math.pow(n.row - r, 2) + Math.pow(n.col - c, 2))\r\n//     num = num.toFixed(1);\r\n//     console.log(num);\r\n//     return num;\r\n// }","import './App.css';\r\nimport React from 'react';\r\nimport PathfindingVisualizer from \"./pathfindingvisualizer/PathfindingVisualizer\";\r\n// import ReactDOM from 'react-dom';\r\n\r\nfunction App() {\r\n  // const GlobalGrid = React.createContext([]);\r\n  // ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />, document.getElementById(\"App\"));\r\n  return (\r\n    \r\n    <div className=\"App\">\r\n      <PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />\r\n      {/* <PathfindingVisualizer /> */}\r\n      \r\n    </div>\r\n  );\r\n}\r\n\r\n// ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}}/>, document.getElementById(\"App\"))\r\n// ReactDOM.render(<Page ref={(ourComponent) => {window.ourComponent = ourComponent}} />, document.getElementById(\"app\"));\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}