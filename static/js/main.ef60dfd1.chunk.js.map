{"version":3,"sources":["pathfindingvisualizer/Node.js","pathfindingvisualizer/MouseStrat.js","pathfindingvisualizer/Algorithms/Dikjstras.js","pathfindingvisualizer/Heuristics.js","pathfindingvisualizer/Algorithms/Astar.js","pathfindingvisualizer/Algorithms/GreedyBestFirst.js","pathfindingvisualizer/Algorithms/BFS.js","pathfindingvisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","startnode","endnode","col","row","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","className","id","Component","originalNodeCol","originalNodeRow","mouseStartNode","mouseEndNode","drawingWalls","GeneralStrat","window","PathfindingVisualizer","grid","newGrid","getNewGridWithWallToggled","setState","mouseLeftDown","gred","slice","END_NODE_COL","END_NODE_ROW","START_NODE_COL","START_NODE_ROW","Dikjstras","startNode","endNode","visitedNodes","unvisitedNodes","getAllNodes","distance","length","console","log","sortNodesByDistance","currentNode","shift","Infinity","isVisited","updateNeighbors","push","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","nei","cur","previousNode","diagonalPathing","unvisitedNeighborsDiag","getUnvisitedNeighborsDiag","sort","nodeA","nodeB","Manhattan","node","Math","abs","Octile","weight","dx","dy","sqrt","Astar","Gcost","sortNodesByDistanceThenHcost","curG","curH","round","Hcost","dist","GreedyBestFirst","sortNodesByHcost","h","isOpen","BFS","openList","sleep","ms","Promise","resolve","setTimeout","resetWall","a","i","GRID_COL_LENGTH","j","GRID_ROW_LENGTH","resetPath","resetGrid","currentRow","newNode","createNode","resetCss","document","getElementById","classList","remove","colorVisited","element","contains","add","ANIMATION_SPEED","colorPath","path","GreedyBestFirstHelper","shortestPathFromEnd","helperAstar","helperDikjstras","helperBFS","mouseStrat2","unshift","neighbors","filter","map","rowId","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","Fragment","href","onClick","toggleDiagonal","mapGrid","but","style","backgroundColor","React","nodes","App","ref","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.ef60dfd1.chunk.js","sourcesContent":["// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport \"./Node.css\";\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    };\r\n\r\n    render() {\r\n        const { startnode, endnode, col, row, isWall, onMouseUp, onMouseDown, onMouseEnter } = this.props;\r\n\r\n        let extraClassName = \"\";\r\n        if (startnode === true) extraClassName = \" startnode\";\r\n        if (endnode === true) extraClassName = \" endnode\"\r\n        if (isWall === true && endnode === false && startnode === false) extraClassName = \" node-wall\";\r\n        return <div\r\n            className={`Node ${extraClassName}`}\r\n            id={`node-${this.props.row}-${this.props.col}`}\r\n\r\n            onMouseDown={()=> onMouseDown(row, col)}\r\n            onMouseUp={()=> onMouseUp(row, col)}\r\n            onMouseEnter={()=> onMouseEnter(row, col)}\r\n        ></div>\r\n    }\r\n\r\n};\r\n","// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport getNewGridWithWallToggled from \"./PathfindingVisualizer\";\r\n\r\n// add user-select: none; to App.css; .App css to fix dragging out of div bug, trying to drag its text\r\n\r\n// current mouse coords\r\n// let mouseRow = 1;\r\n// let mouseCol = 1;\r\n// mouse coords at click\r\nlet originalNodeCol = null;\r\nlet originalNodeRow = null;\r\n// flags for which node is clicked\r\nlet mouseStartNode = false;\r\nlet mouseEndNode = false;\r\n\r\nlet drawingWalls = false;\r\n\r\nexport class GeneralStrat {\r\n\r\n    handleMouseDown(row, col) {\r\n        if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n            mouseStartNode = true;\r\n        } else if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n            mouseEndNode = true;\r\n        } else {\r\n            drawingWalls = true;\r\n            const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n            window.PathfindingVisualizer.setState({ grid: newGrid });\r\n        }\r\n        originalNodeCol = col;\r\n        originalNodeRow = row;\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n        // console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n        if (drawingWalls) {\r\n            const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n            window.PathfindingVisualizer.setState({ grid: newGrid });\r\n        }\r\n\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if (mouseEndNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].endnode = false;\r\n            gred[row][col].endnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n        }\r\n        if (mouseStartNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].startnode = false;\r\n            gred[row][col].startnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n        }\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n        mouseEndNode = false;\r\n        mouseStartNode = false;\r\n        drawingWalls = false;\r\n    }\r\n\r\n}\r\n\r\n// export class StartEndStrat {\r\n//     handleMouseDown(row, col) {\r\n//         // console.log(originalNode);\r\n//         if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n//             mouseStartNode = true;\r\n//             // console.log(mouseStartNode);\r\n//         }\r\n//         if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n//             mouseEndNode = true;\r\n//             // console.log(mouseStartNode);\r\n//         }\r\n\r\n//         originalNodeCol = col;\r\n//         originalNodeRow = row;\r\n//         window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n//         console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n//     }\r\n\r\n//     handleMouseEnter(row, col) {\r\n\r\n//     }\r\n\r\n//     handleMouseUp(row, col) {\r\n//         if (mouseEndNode) {\r\n//             const gred = window.PathfindingVisualizer.state.grid.slice();\r\n//             gred[originalNodeRow][originalNodeCol].endnode = false;\r\n//             gred[row][col].endnode = true;\r\n//             window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n//         }\r\n//         if (mouseStartNode) {\r\n//             const gred = window.PathfindingVisualizer.state.grid.slice();\r\n//             gred[originalNodeRow][originalNodeCol].startnode = false;\r\n//             gred[row][col].startnode = true;\r\n//             window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n//         }\r\n//         window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n//         mouseEndNode = false;\r\n//         mouseStartNode = false;\r\n//     }\r\n// }\r\n\r\n// export class WallStrat {\r\n//     handleMouseDown(row, col) {\r\n//         const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n//         window.PathfindingVisualizer.setState({ grid: newGrid, mouseLeftDown: true });\r\n//     }\r\n\r\n//     handleMouseEnter(row, col) {\r\n//         if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n//         const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n//         window.PathfindingVisualizer.setState({ grid: newGrid });\r\n//     }\r\n\r\n//     handleMouseUp(row, col) {\r\n//         window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n//     }\r\n// }","import { getAllNodes, } from \"../PathfindingVisualizer\";\r\n\r\n\r\n\r\n// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\nexport function Dikjstras(grid, startNode, endNode) {\r\n    const visitedNodes = [];\r\n\r\n    // 1. Mark all nodes unvisited(already default) Create set of all unvisited\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    // console.log(unvisitedNodes);\r\n\r\n    // 2. Set initial node distance to 0, rest to infinity (already default)\r\n    startNode.distance = 0;\r\n\r\n    // !! = cast to boolean\r\n    while (!!unvisitedNodes.length) {\r\n        console.log(\"dijkstra\");\r\n        sortNodesByDistance(unvisitedNodes);\r\n        // console.log(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n        // 3. Calculate distance of all unvisited neighbor nodes through currentNode\r\n        //    compare new distance with assigned distance, assign smaller distance.\r\n        updateNeighbors(grid, currentNode);\r\n        // 4. Mark currentNode visted, remove from unvisited set.\r\n        // unvisitedNodes.shift();\r\n        visitedNodes.push(currentNode);\r\n\r\n        // 5. if endNode is visited or smallest distance of unvisited nodes is infinite\r\n        //    stop algo\r\n        // 6. select unvisited node with lowest distance, set to current node\r\n        //    loop back to step 3\r\n        // console.log(grid);\r\n    }\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode) {\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    // const unvisitedNeighbors = getUnvisitedNeighbors2(grid, currentNode);\\\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let nei = neighbor.distance;\r\n        let cur = currentNode.distance + 1;\r\n        neighbor.distance = nei > cur ? cur: nei;\r\n        // neighbor.distance = currentNode.distance + 1; //neighbor dist always greater\r\n        if (neighbor.previousNode == null) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    if(window.PathfindingVisualizer.diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let nei = neighbor.distance;\r\n            let cur = currentNode.distance + 1.4;\r\n            neighbor.distance = nei > cur ? cur: nei;\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// sorts input array of nodes by their distance\r\nexport function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n","\r\n\r\nexport function Manhattan(node) {\r\n    // console.log('start manhattan');\r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    // console.log(dy);\r\n    return (dx + dy);\r\n}\r\n\r\nexport function Octile(node, weight) {\r\n    \r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    return (weight * (Math.sqrt(dx + dy)));\r\n}","import { getAllNodes } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\n\r\n// Gcost = distance from starting node\r\n// Hcost (heuristic) = distance from end node\r\n// Fcost = Gcost + Hcost (using distance var)\r\n\r\n\r\nexport function Astar(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    startNode.distance = 0;\r\n    startNode.Gcost = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistanceThenHcost(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode, diagonalPathing);\r\n\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\n\r\nfunction updateNeighbors(grid, currentNode, diagonalPathing) {\r\n    // console.log('astar updateneighbors');\r\n\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let curG = currentNode.Gcost + 1;\r\n        // let neiG = neighbor.Gcost;\r\n        // neighbor.Gcost = neiG > curG ? curG : neiG;\r\n        let curH = 0;\r\n        if (diagonalPathing) {\r\n            curH = Octile(neighbor, 5);\r\n        } else {\r\n            curH = Manhattan(neighbor);\r\n        }\r\n        // curH = Manhattan(neighbor);\r\n        if (curG + curH < neighbor.distance) {\r\n            neighbor.distance = Math.round(curG + curH);\r\n            neighbor.previousNode = currentNode;\r\n            neighbor.Hcost = curH;\r\n            neighbor.Gcost = curG;\r\n        }\r\n    }\r\n\r\n    if (diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let curG = currentNode.Gcost + 1.4;\r\n            let curH = Octile(neighbor, 5);\r\n            neighbor.Hcost = curH;\r\n            // let curH = Manhattan(neighbor);\r\n            if (curG + curH < neighbor.distance) {\r\n                if (neighbor.Gcost > curG) neighbor.Gcost = curG;\r\n                let dist = Math.round(curG + curH);\r\n                if (dist < neighbor.distance) {\r\n                    neighbor.distance = dist\r\n                    neighbor.previousNode = currentNode;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n// if both distance equal, first condition is 0 and considered false, then second part of condition is executed.\r\nexport function sortNodesByDistanceThenHcost(unvisitedNodes) {\r\n    unvisitedNodes.sort(function (nodeA, nodeB) {\r\n        return nodeA.distance - nodeB.distance || nodeA.Hcost - nodeB.Hcost\r\n    })\r\n}","import { getAllNodes } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\n\r\nexport function GreedyBestFirst(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    startNode.distance = 0;\r\n    startNode.Hcost = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByHcost(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.Hcost === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode, diagonalPathing);\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode, diagonalPathing) {\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let h = 0\r\n        if (!neighbor.isOpen) \r\n            neighbor.isOpen = true;\r\n        \r\n        if (!diagonalPathing)\r\n            h = Manhattan(neighbor);\r\n        else\r\n            h = Octile(neighbor, 1);\r\n\r\n        if (h < neighbor.Hcost) {\r\n            neighbor.Hcost = h;\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    if (diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let h = 0\r\n            if (!neighbor.isOpen) {\r\n                neighbor.isOpen = true;\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n            h = Octile(neighbor, 1)\r\n\r\n            if (h < neighbor.Hcost) {\r\n                neighbor.Hcost = h;\r\n            }\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\nexport function sortNodesByHcost(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.Hcost - nodeB.Hcost);\r\n}","export function BFS(grid, startNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const openList = [];\r\n    openList.push(startNode);\r\n\r\n    while (!!openList.length) {\r\n        const currentNode = openList.shift();\r\n        visitedNodes.push(currentNode);\r\n        if (currentNode.endnode) break;\r\n        if (currentNode.isWall) continue;\r\n\r\n        const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n        // console.log(unvisitedNeighbors);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            if(neighbor.isWall) continue;\r\n            openList.push(neighbor);\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n            neighbor.isVisited = true;\r\n        }\r\n\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            if(neighbor.isWall) continue;\r\n            openList.push(neighbor);\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n            neighbor.isVisited = true;\r\n        }\r\n    }\r\n    startNode.previousNode = null;\r\n    return visitedNodes;\r\n\r\n}","import React from \"react\";\r\nimport Node from \"./Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { setTimeout } from 'timers';\r\nimport { GeneralStrat } from \"./MouseStrat\";\r\n// import { StartEndStrat, WallStrat, } from \"./MouseStrat\";\r\nimport { Dikjstras } from \"./Algorithms/Dikjstras\";\r\nimport { Astar } from \"./Algorithms/Astar\"\r\nimport { GreedyBestFirst } from \"./Algorithms/GreedyBestFirst\"\r\nimport { BFS } from \"./Algorithms/BFS\"\r\n\r\nconst ANIMATION_SPEED = 100;\r\n\r\nconst sleep = (ms) => {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n};\r\n\r\n// React uses JSX not plain javascript, first letter of tag indicates elements. \r\n// Uppercase used to specify react components; ie cant camelCase.\r\nexport default class PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            grid: [],\r\n            mouseLeftDown: false,\r\n            GRID_ROW_LENGTH: 45,\r\n            GRID_COL_LENGTH: 25,\r\n\r\n            START_NODE_ROW: 10,\r\n            START_NODE_COL: 7,\r\n            END_NODE_ROW: 10,\r\n            END_NODE_COL: 30,\r\n        };\r\n        const diagonalPathing = false;\r\n        const mouseStrat2 = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetGrid();\r\n        this.mouseStrat2 = new GeneralStrat();\r\n        this.diagonalPathing = false;\r\n    }\r\n\r\n    createNode(row, col) {\r\n        return {\r\n            previousNode: null,\r\n            row: row,\r\n            col: col,\r\n            Gcost: Infinity,\r\n            Hcost: Infinity,\r\n            distance: Infinity,\r\n            isOpen: false,\r\n            isVisited: false,\r\n            startnode: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            endnode: row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL,\r\n            isWall: false,\r\n        }\r\n    }\r\n\r\n    resetWall = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].isWall = false;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetPath = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].previousNode = null;\r\n                grid[i][j].distance = Infinity;\r\n                grid[i][j].isVisited = false;\r\n                grid[i][j].Gcost = Infinity;\r\n                grid[i][j].Hcost = Infinity;\r\n                grid[i][j].isOpen = false;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetGrid = async () => {\r\n        const grid = [];\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            let currentRow = [];\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                const newNode = this.createNode(i, j)\r\n                currentRow.push(newNode);\r\n            }\r\n            grid.push(currentRow);\r\n        }\r\n        this.setState({ grid });\r\n        return;\r\n    }\r\n\r\n    resetCss = async () => {\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                let node = document.getElementById(`node-${i}-${j}`);\r\n\r\n                //these classes not set by Node.js, not in state grid so manual remove, only for animation\r\n                node.classList.remove(\"node-visited\");\r\n                node.classList.remove(\"node-path\");\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n\r\n    colorVisited = async (visitedNodes) => {\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            const node = visitedNodes[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-visited\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.1);\r\n        }\r\n        return;\r\n    }\r\n\r\n    colorPath = async (path) => {\r\n        for (let i = 0; i < path.length; i++) {\r\n            const node = path[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-path\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.5);\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Follows previousNode property from endNode to startNode.\r\n    // Must be called AFTER pathfinding algo\r\n    shortestPathFromEnd(startNode, endNode) {\r\n        const path = [];\r\n        let currentNode = endNode\r\n        while (currentNode != null) {\r\n            // console.log(currentNode);\r\n            path.unshift(currentNode);\r\n            currentNode = currentNode.previousNode;\r\n        }\r\n        return path;\r\n    }\r\n\r\n    // Changes grid, find better complexity\r\n    getNewGridWithWallToggled(grid, row, col) {\r\n        const newGrid = grid.slice();      // bad slicing every time mouse goes in new node\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    };\r\n\r\n\r\n    // return array of unvisited neighbors of node\r\n    // does not include diagonal\r\n    getUnvisitedNeighbors(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    // also need checks to allow / disallow diagonal pathing through corners\r\n    getUnvisitedNeighborsDiag(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (this.diagonalPathing) {\r\n            // ⬉\r\n            if (row > 0 && col > 0) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row - 1][col - 1]);\r\n            }\r\n            // ⬈\r\n            if (row > 0 && col < grid[0].length - 1) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row - 1][col + 1]);\r\n            }\r\n            // ⬊\r\n            if (row < grid.length - 1 && col < grid[0].length - 1) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row + 1][col + 1]);\r\n            }\r\n            // ⬋\r\n            if (row < grid.length - 1 && col > 0) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row + 1][col - 1]);\r\n            }\r\n        }\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    mapGrid() {\r\n        const { grid } = this.state;\r\n        return grid.map((row, rowId) => {\r\n            return (\r\n                <div key={rowId}>\r\n                    {row.map((node, nodeId) => {\r\n                        let { startnode, endnode, isWall, } = node;\r\n                        return <Node\r\n                            key={nodeId}\r\n                            row={rowId}\r\n                            col={nodeId}\r\n                            startnode={startnode}\r\n                            endnode={endnode}\r\n                            // distance={distance}\r\n                            // isVisited={isVisited}\r\n                            isWall={isWall}\r\n                            // previousNode={previousNode}  \r\n                            // onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseEnter={(row, col) => this.mouseStrat2.handleMouseEnter(row, col)}\r\n                            onMouseUp={(row, col) => this.mouseStrat2.handleMouseUp(row, col)}\r\n\r\n                        ></Node>\r\n                    })}\r\n                </div>\r\n            )\r\n        })\r\n    }\r\n\r\n    render() {\r\n        // const { grid } = this.state;\r\n        return (\r\n            <React.Fragment>\r\n                <div className=\"button-bar\">\r\n                    <a href=\"http://patgiok.azurewebsites.net/\"><button>Home</button></a>\r\n                    {/* <button onClick={() => console.log(this.state.grid)}> check grid</button> */}\r\n                    <button onClick={() => this.resetCss()}>reset path</button>\r\n                    {/* <button onClick={() => this.resetGrid()}>reset grid</button> */}\r\n                    <button onClick={() => this.resetWall()}>reset walls</button>\r\n                    <button onClick={() => this.GreedyBestFirstHelper()}>BestFirst</button>\r\n                    <button onClick={() => this.helperAstar()}>Astar</button>\r\n                    <button onClick={() => this.helperDikjstras()}>Dikjstras</button>\r\n                    <button onClick={() => this.helperBFS()}>BFS</button>\r\n                    <button id=\"togglebutton\" onClick={() => this.toggleDiagonal()}>diagonals</button>\r\n                    {/* <button onClick={() => this.mouseStrat2 = new StartEndStrat(this)}>startendstrat</button>\r\n                    <button onClick={() => this.mouseStrat2 = new WallStrat(this)}>wallstrat</button> */}\r\n                </div>\r\n                <div className=\"grid-container\">\r\n                    {this.mapGrid()}\r\n                </div>\r\n            </React.Fragment>\r\n        );\r\n    }\r\n    toggleDiagonal() {\r\n        this.diagonalPathing = !this.diagonalPathing;\r\n        var but = document.getElementById(\"togglebutton\");\r\n        if (this.diagonalPathing) {\r\n            but.style.backgroundColor = \"#F22EFC\";\r\n        } else {\r\n            but.style.backgroundColor = \"#222570\";\r\n        }\r\n        console.log(`diagonal pathing: ${this.diagonalPathing}`);\r\n    }\r\n\r\n    GreedyBestFirstHelper = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = GreedyBestFirst(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperAstar = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Astar(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperDikjstras = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Dikjstras(grid, startnode, endnode);\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperBFS = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = BFS(grid, startnode, this.diagonalPathing);\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n}\r\n\r\n//return array of all nodes in 1d array\r\nexport function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// takes too long, has to check every node\r\n// export function getUnvisitedNeighbors3(nodes, currentNode) {\r\n//     console.log('getUnvisitedNeighbors3');\r\n//     console.log(nodes);\r\n//     // console.log(currentNode);\r\n//     const { row, col, } = currentNode;\r\n//     let neighbors = [];\r\n//     neighbors = nodes.filter(\r\n//         function (node) {\r\n//             return !node.isVisited && dist(node, row, col) == 1.0\r\n\r\n//             // return !node.isVisited && dist(node, row, col) == 1.4\r\n//         })\r\n//     console.log(neighbors);\r\n//     return neighbors;\r\n// }\r\n// function dist(n, r, c) {\r\n//     let num = Math.sqrt(Math.pow(n.row - r, 2) + Math.pow(n.col - c, 2))\r\n//     num = num.toFixed(1);\r\n//     console.log(num);\r\n//     return num;\r\n// }","import './App.css';\r\nimport React from 'react';\r\nimport PathfindingVisualizer from \"./pathfindingvisualizer/PathfindingVisualizer\";\r\n// import ReactDOM from 'react-dom';\r\n\r\nfunction App() {\r\n  // const GlobalGrid = React.createContext([]);\r\n  // ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />, document.getElementById(\"App\"));\r\n  return (\r\n    \r\n    <div className=\"App\">\r\n      <PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />\r\n      {/* <PathfindingVisualizer /> */}\r\n      \r\n    </div>\r\n  );\r\n}\r\n\r\n// ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}}/>, document.getElementById(\"App\"))\r\n// ReactDOM.render(<Page ref={(ourComponent) => {window.ourComponent = ourComponent}} />, document.getElementById(\"app\"));\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}