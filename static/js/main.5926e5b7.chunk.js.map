{"version":3,"sources":["pathfindingvisualizer/Node.js","pathfindingvisualizer/Algorithms/Dikjstras.js","pathfindingvisualizer/MouseStrat.js","pathfindingvisualizer/Heuristics.js","pathfindingvisualizer/Algorithms/Astar.js","pathfindingvisualizer/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","startnode","endnode","col","row","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","className","id","Component","Dikjstras","grid","startNode","endNode","visitedNodes","unvisitedNodes","getAllNodes","distance","length","sortNodesByDistance","currentNode","shift","Infinity","isVisited","updateNeighbors","push","unvisitedNeighbors","window","PathfindingVisualizer","getUnvisitedNeighbors","neighbor","nei","cur","previousNode","diagonalPathing","unvisitedNeighborsDiag","getUnvisitedNeighborsDiag","originalNodeCol","originalNodeRow","mouseStartNode","mouseEndNode","StartEndStrat","setState","mouseLeftDown","console","log","gred","slice","END_NODE_COL","END_NODE_ROW","START_NODE_COL","START_NODE_ROW","WallStrat","newGrid","getNewGridWithWallToggled","Octile","node","dx","Math","abs","dy","sqrt","Astar","Gcost","sortNodesByDistanceThenHcost","curG","neiG","Hcost","dist","sleep","ms","Promise","resolve","setTimeout","resetWall","a","i","GRID_COL_LENGTH","j","GRID_ROW_LENGTH","resetPath","resetGrid","currentRow","newNode","createNode","resetCss","document","getElementById","classList","remove","helperAstar","path","shortestPathFromEnd","colorVisited","colorPath","helperDikjstras","element","contains","add","ANIMATION_SPEED","mouseStrat2","map","rowId","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","unshift","neighbors","filter","Fragment","onClick","toggleDiagonal","href","mapGrid","React","nodes","sort","nodeA","nodeB","App","ref","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.5926e5b7.chunk.js","sourcesContent":["// import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport \"./Node.css\";\r\nimport React, { Component } from 'react';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    };\r\n\r\n    render() {\r\n        const { startnode, endnode, col, row, isWall, onMouseUp, onMouseDown, onMouseEnter } = this.props;\r\n\r\n        let extraClassName = \"\";\r\n        if (startnode === true) extraClassName = \" startnode\";\r\n        if (endnode === true) extraClassName = \" endnode\"\r\n        if (isWall === true && endnode === false && startnode === false) extraClassName = \" node-wall\";\r\n        return <div\r\n            className={`Node ${extraClassName}`}\r\n            id={`node-${this.props.row}-${this.props.col}`}\r\n\r\n            onMouseDown={()=> onMouseDown(row, col)}\r\n            onMouseUp={()=> onMouseUp(row, col)}\r\n            onMouseEnter={()=> onMouseEnter(row, col)}\r\n        ></div>\r\n    }\r\n\r\n};\r\n","import { getAllNodes, getUnvisitedNeighbors2, getUnvisitedNeighbors, getUnvisitedNeighborsDiag, sortNodesByDistance } from \"../PathfindingVisualizer\";\r\n\r\n\r\n\r\n// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\nexport function Dikjstras(grid, startNode, endNode) {\r\n    const visitedNodes = [];\r\n\r\n    // 1. Mark all nodes unvisited(already default) Create set of all unvisited\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    // console.log(unvisitedNodes);\r\n\r\n    // 2. Set initial node distance to 0, rest to infinity (already default)\r\n    startNode.distance = 0;\r\n\r\n    // !! = cast to boolean\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        // console.log(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n        // 3. Calculate distance of all unvisited neighbor nodes through currentNode\r\n        //    compare new distance with assigned distance, assign smaller distance.\r\n        updateNeighbors(grid, currentNode);\r\n        // 4. Mark currentNode visted, remove from unvisited set.\r\n        // unvisitedNodes.shift();\r\n        visitedNodes.push(currentNode);\r\n\r\n        // 5. if endNode is visited or smallest distance of unvisited nodes is infinite\r\n        //    stop algo\r\n        // 6. select unvisited node with lowest distance, set to current node\r\n        //    loop back to step 3\r\n        // console.log(grid);\r\n    }\r\n}\r\n\r\nfunction updateNeighbors(grid, currentNode) {\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    // const unvisitedNeighbors = getUnvisitedNeighbors2(grid, currentNode);\\\r\n\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        let nei = neighbor.distance;\r\n        let cur = currentNode.distance + 1;\r\n        neighbor.distance = nei > cur ? cur: nei;\r\n        // neighbor.distance = currentNode.distance + 1; //neighbor dist always greater\r\n        if (neighbor.previousNode == null) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    if(window.PathfindingVisualizer.diagonalPathing) {\r\n        const unvisitedNeighborsDiag = window.PathfindingVisualizer.getUnvisitedNeighborsDiag(grid, currentNode);\r\n        for (const neighbor of unvisitedNeighborsDiag) {\r\n            let nei = neighbor.distance;\r\n            let cur = currentNode.distance + 1.4;\r\n            neighbor.distance = nei > cur ? cur: nei;\r\n            // neighbor.distance = currentNode.distance + 1.4; //neighbor dist always greater\r\n            if (neighbor.previousNode == null) {\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import PathfindingVisualizer from \"./PathfindingVisualizer\";\r\nimport getNewGridWithWallToggled from \"./PathfindingVisualizer\";\r\n\r\n// add user-select: none; to App.css; .App css to fix dragging out of div bug, trying to drag its text\r\n\r\n// current mouse coords\r\nlet mouseRow = 1;\r\nlet mouseCol = 1;\r\n// mouse coords at click\r\nlet originalNodeCol = null;\r\nlet originalNodeRow = null;\r\n// flags for which node is clicked\r\nlet mouseStartNode = false;\r\nlet mouseEndNode = false;\r\n\r\nexport class StartEndStrat {\r\n    handleMouseDown(row, col) {\r\n        // console.log(originalNode);\r\n        if (window.PathfindingVisualizer.state.grid[row][col].startnode) {\r\n            mouseStartNode = true;\r\n            // console.log(mouseStartNode);\r\n        }\r\n        if (window.PathfindingVisualizer.state.grid[row][col].endnode) {\r\n            mouseEndNode = true;\r\n            // console.log(mouseStartNode);\r\n        }\r\n\r\n        originalNodeCol = col;\r\n        originalNodeRow = row;\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: true });\r\n        console.log(`mouse: ${mouseStartNode} , state:  ${window.PathfindingVisualizer.state.mouseLeftDown}`);\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if (mouseEndNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].endnode = false;\r\n            gred[row][col].endnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, END_NODE_COL: col, END_NODE_ROW: row });\r\n        }\r\n        if (mouseStartNode) {\r\n            const gred = window.PathfindingVisualizer.state.grid.slice();\r\n            gred[originalNodeRow][originalNodeCol].startnode = false;\r\n            gred[row][col].startnode = true;\r\n            window.PathfindingVisualizer.setState({ grid: gred, mouseLeftDown: false, START_NODE_COL: col, START_NODE_ROW: row });\r\n        }\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false});\r\n        mouseEndNode = false;\r\n        mouseStartNode = false;\r\n    }\r\n}\r\n\r\nexport class WallStrat {\r\n    handleMouseDown(row, col) {\r\n        const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n        window.PathfindingVisualizer.setState({ grid: newGrid, mouseLeftDown: true });\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!window.PathfindingVisualizer.state.mouseLeftDown) return;\r\n        const newGrid = window.PathfindingVisualizer.getNewGridWithWallToggled(window.PathfindingVisualizer.state.grid, row, col);\r\n        window.PathfindingVisualizer.setState({ grid: newGrid });\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        window.PathfindingVisualizer.setState({ mouseLeftDown: false });\r\n    }\r\n}","\r\n\r\nexport function Manhattan(node) {\r\n    // console.log('start manhattan');\r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    // console.log(window.PathfindingVisualizer.state.END_NODE_COL)\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    return (dx + dy);\r\n}\r\n\r\nexport function Octile(node) {\r\n    \r\n    let dx = Math.abs(node.col - window.PathfindingVisualizer.state.END_NODE_COL);\r\n    let dy = Math.abs(node.row - window.PathfindingVisualizer.state.END_NODE_ROW);\r\n    return (2.5 * (Math.sqrt(dx + dy)));\r\n}","import { getAllNodes, getUnvisitedNeighbors, getUnvisitedNeighborsDiag, sortNodesByDistance, sortNodesByDistanceThenHcost } from \"../PathfindingVisualizer\";\r\nimport { Manhattan, Octile, } from \"../Heuristics\";\r\n\r\n// Gcost = distance from starting node\r\n// Hcost (heuristic) = distance from end node\r\n// Fcost = Gcost + Hcost (using distance var)\r\n\r\n\r\nexport function Astar(grid, startNode, endNode, diagonalPathing) {\r\n    const visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    startNode.distance = 0;\r\n    startNode.Gcost = 0;\r\n\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistanceThenHcost(unvisitedNodes);\r\n        const currentNode = unvisitedNodes.shift();\r\n\r\n        // if all nodes distance is infinity, we are stuck\r\n        if (currentNode.distance === Infinity) return visitedNodes;\r\n        if (currentNode.isWall) continue;\r\n\r\n        currentNode.isVisited = true;\r\n        if (endNode.isVisited) return visitedNodes;\r\n\r\n        updateNeighbors(grid, currentNode);\r\n\r\n        visitedNodes.push(currentNode);\r\n    }\r\n}\r\n\r\n\r\nfunction updateNeighbors(grid, currentNode) {\r\n    console.log('astar updateneighbors');\r\n\r\n    const unvisitedNeighbors = window.PathfindingVisualizer.getUnvisitedNeighbors(grid, currentNode);\r\n    for(const neighbor of unvisitedNeighbors) {\r\n        let curG = currentNode.Gcost + 1;\r\n        let neiG = neighbor.Gcost;\r\n        neighbor.Gcost = neiG > curG ? curG : neiG;\r\n        if(neighbor.Hcost = Infinity) neighbor.Hcost = Octile(currentNode);\r\n        // if(neighbor.Hcost = Infinity) neighbor.Hcost = Manhattan(currentNode);\r\n        \r\n        // console.log(neighbor.Hcost);\r\n        let dist = neighbor.Gcost + neighbor.Hcost;\r\n        console.log(dist);\r\n        neighbor.distance = dist;\r\n        // console.log(neighbor.distance);\r\n        if (neighbor.previousNode == null) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n    }\r\n\r\n    return;\r\n}","import React from \"react\";\r\nimport Node from \"./Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { Dikjstras } from \"./Algorithms/Dikjstras\";\r\nimport { setTimeout } from 'timers';\r\nimport { StartEndStrat, WallStrat } from \"./MouseStrat\";\r\nimport { Astar } from \"./Algorithms/Astar\"\r\n\r\nconst ANIMATION_SPEED = 100;\r\n\r\nconst sleep = (ms) => {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n};\r\n\r\n// React uses JSX not plain javascript, first letter of tag indicates elements. \r\n// Uppercase used to specify react components; ie cant camelCase.\r\nexport default class PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            grid: [],\r\n            mouseLeftDown: false,\r\n            GRID_ROW_LENGTH: 45,\r\n            GRID_COL_LENGTH: 25,\r\n\r\n            START_NODE_ROW: 7,\r\n            START_NODE_COL: 3,\r\n            END_NODE_ROW: 7,\r\n            END_NODE_COL: 20,\r\n        };\r\n        const diagonalPathing = false;\r\n        const mouseStrat2 = null;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.resetGrid();\r\n        this.mouseStrat2 = new StartEndStrat();\r\n        this.diagonalPathing = false;\r\n        // console.log(this.mouseStrat2);\r\n    }\r\n\r\n    resetWall = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].isWall = false;\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetPath = async () => {\r\n        const grid = this.state.grid;\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                grid[i][j].previousNode = null;\r\n                grid[i][j].distance = Infinity;\r\n                grid[i][j].isVisited = false;\r\n                grid[i][j].Gcost = Infinity;\r\n                grid[i][j].Hcost = Infinity;\r\n\r\n            }\r\n        }\r\n        this.setState({ grid: grid });\r\n        return;\r\n    }\r\n\r\n    resetGrid = async () => {\r\n        const grid = [];\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            let currentRow = [];\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                const newNode = this.createNode(i, j)\r\n                currentRow.push(newNode);\r\n            }\r\n            grid.push(currentRow);\r\n        }\r\n        this.setState({ grid });\r\n        return;\r\n    }\r\n\r\n    resetCss = async () => {\r\n        for (let i = 0; i < this.state.GRID_COL_LENGTH; i++) {\r\n            for (let j = 0; j < this.state.GRID_ROW_LENGTH; j++) {\r\n                let node = document.getElementById(`node-${i}-${j}`);\r\n\r\n                //these classes not set by Node.js, not in state grid so manual remove, only for animation\r\n                node.classList.remove(\"node-visited\");\r\n                node.classList.remove(\"node-path\");\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    mapGrid() {\r\n        const { grid } = this.state;\r\n        return grid.map((row, rowId) => {\r\n            return (\r\n                <div key={rowId}>\r\n                    {row.map((node, nodeId) => {\r\n                        let { startnode, endnode, distance, isVisited, isWall, previousNode } = node;\r\n                        return <Node\r\n                            key={nodeId}\r\n                            row={rowId}\r\n                            col={nodeId}\r\n                            startnode={startnode}\r\n                            endnode={endnode}\r\n                            // distance={distance}\r\n                            // isVisited={isVisited}\r\n                            isWall={isWall}\r\n                            // previousNode={previousNode}  \r\n                            // onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseDown={(row, col) => this.mouseStrat2.handleMouseDown(row, col)}\r\n                            onMouseEnter={(row, col) => this.mouseStrat2.handleMouseEnter(row, col)}\r\n                            onMouseUp={(row, col) => this.mouseStrat2.handleMouseUp(row, col)}\r\n\r\n                        ></Node>\r\n                    })}\r\n                </div>\r\n            )\r\n        })\r\n    }\r\n\r\n    // Follows previousNode property from endNode to startNode.\r\n    // Must be called AFTER pathfinding algo\r\n    shortestPathFromEnd(startNode, endNode) {\r\n        const path = [];\r\n        let currentNode = endNode\r\n        while (currentNode != null) {\r\n            // console.log(currentNode);\r\n            path.unshift(currentNode);\r\n            currentNode = currentNode.previousNode;\r\n        }\r\n        return path;\r\n    }\r\n\r\n    helperAstar = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Astar(grid, startnode, endnode, this.diagonalPathing);\r\n\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    helperDikjstras = async () => {\r\n        await this.resetCss();\r\n        await this.resetPath();\r\n        const { grid } = this.state;\r\n        const startnode = grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n        const endnode = grid[this.state.END_NODE_ROW][this.state.END_NODE_COL];\r\n        const visitedNodes = Dikjstras(grid, startnode, endnode);\r\n        // console.log(visitedNodes);\r\n        const path = this.shortestPathFromEnd(startnode, endnode);\r\n\r\n        await this.colorVisited(visitedNodes);\r\n        await this.colorPath(path);\r\n    }\r\n\r\n    colorVisited = async (visitedNodes) => {\r\n        for (let i = 0; i < visitedNodes.length; i++) {\r\n            const node = visitedNodes[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-visited\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.1);\r\n        }\r\n        return;\r\n    }\r\n\r\n    colorPath = async (path) => {\r\n        for (let i = 0; i < path.length; i++) {\r\n            const node = path[i];\r\n            var element = document.getElementById(`node-${node.row}-${node.col}`);\r\n            if (!element.classList.contains(\"startnode\") && !element.classList.contains(\"endnode\")) {\r\n                element.classList.add(\"node-path\");\r\n            }\r\n            await sleep(ANIMATION_SPEED * 0.5);\r\n        }\r\n        return;\r\n    }\r\n\r\n    getNewGridWithWallToggled(grid, row, col) {\r\n        const newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        const newNode = {\r\n            ...node,\r\n            isWall: !node.isWall,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n        return newGrid;\r\n    };\r\n\r\n    createNode(row, col) {\r\n        return {\r\n            distance: Infinity,\r\n            isVisited: false,\r\n            row: row,\r\n            col: col,\r\n            startnode: row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            endnode: row === this.state.END_NODE_ROW && col === this.state.END_NODE_COL,\r\n            isWall: false,\r\n            previousNode: null,\r\n            Hcost: Infinity,\r\n            Gcost: Infinity,\r\n            \r\n        }\r\n    }\r\n\r\n    toggleDiagonal() {\r\n        this.diagonalPathing = !this.diagonalPathing;\r\n        console.log(this.diagonalPathing);\r\n    }\r\n\r\n    // return array of unvisited neighbors of node\r\n    // does not include diagonal\r\n    getUnvisitedNeighbors(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n        if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n        if (row > 0) neighbors.push(grid[row - 1][col]);\r\n        if (col > 0) neighbors.push(grid[row][col - 1]);\r\n\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    // also need checks to allow / disallow diagonal pathing through corners\r\n    getUnvisitedNeighborsDiag(grid, node) {\r\n        const { row, col } = node;\r\n        let neighbors = [];\r\n        if (this.diagonalPathing) {\r\n            // ⬉\r\n            if (row > 0 && col > 0) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row - 1][col - 1]);\r\n            }\r\n            // ⬈\r\n            if (row > 0 && col < grid[0].length - 1) {\r\n                if (!grid[row - 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row - 1][col + 1]);\r\n            }\r\n            // ⬊\r\n            if (row < grid.length - 1 && col < grid[0].length - 1) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col + 1].isWall)\r\n                    neighbors.push(grid[row + 1][col + 1]);\r\n            }\r\n            // ⬋\r\n            if (row < grid.length - 1 && col > 0) {\r\n                if (!grid[row + 1][col].isWall || !grid[row][col - 1].isWall)\r\n                    neighbors.push(grid[row + 1][col - 1]);\r\n            }\r\n        }\r\n\r\n        neighbors = neighbors.filter(neighbor => !neighbor.isVisited);\r\n        return neighbors;\r\n    }\r\n\r\n    render() {\r\n        const { grid } = this.state;\r\n        return (\r\n            <React.Fragment>\r\n                <div className=\"button-bar\">\r\n                    {/* <button onClick={() => console.log(this.state.grid)}> check grid</button> */}\r\n                    <button onClick={() => this.resetGrid()}>reset grid</button>\r\n                    <button onClick={() => this.resetWall()}>reset walls</button>\r\n                    <button onClick={() => this.helperAstar()}>Astar</button>\r\n                    <button onClick={() => this.helperDikjstras()}>Dikjstras</button>\r\n                    <button onClick={() => this.mouseStrat2 = new StartEndStrat(this)}>startendstrat</button>\r\n                    <button onClick={() => this.mouseStrat2 = new WallStrat(this)}>wallstrat</button>\r\n                    <button onClick={() => this.toggleDiagonal()}>diagonals</button>\r\n                    <a href=\"http://patgiok.azurewebsites.net/\"><button>Home</button></a>\r\n                </div>\r\n                <div className=\"grid-container\">\r\n                    {this.mapGrid()}\r\n                </div>\r\n            </React.Fragment>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n//return array of all nodes in 1d array\r\nexport function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// sorts input array of nodes by their distance\r\nexport function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n// if both distance equal, first condition is 0 and considered false, then second part of condition is executed.\r\nexport function sortNodesByDistanceThenHcost(unvisitedNodes) {\r\n    unvisitedNodes.sort(function (nodeA, nodeB) {\r\n        return nodeA.distance - nodeB.distance || nodeA.Hcost - nodeB.Hcost\r\n\r\n    })\r\n}\r\n\r\n\r\n// takes too long, has to check every node\r\n// export function getUnvisitedNeighbors3(nodes, currentNode) {\r\n//     console.log('getUnvisitedNeighbors3');\r\n//     console.log(nodes);\r\n//     // console.log(currentNode);\r\n//     const { row, col, } = currentNode;\r\n//     let neighbors = [];\r\n//     neighbors = nodes.filter(\r\n//         function (node) {\r\n//             return !node.isVisited && dist(node, row, col) == 1.0\r\n\r\n//             // return !node.isVisited && dist(node, row, col) == 1.4\r\n//         })\r\n//     console.log(neighbors);\r\n//     return neighbors;\r\n// }\r\n// function dist(n, r, c) {\r\n//     let num = Math.sqrt(Math.pow(n.row - r, 2) + Math.pow(n.col - c, 2))\r\n//     num = num.toFixed(1);\r\n//     console.log(num);\r\n//     return num;\r\n// }","import './App.css';\r\nimport React from 'react';\r\nimport PathfindingVisualizer from \"./pathfindingvisualizer/PathfindingVisualizer\";\r\n// import ReactDOM from 'react-dom';\r\n\r\nfunction App() {\r\n  // const GlobalGrid = React.createContext([]);\r\n  // ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />, document.getElementById(\"App\"));\r\n  return (\r\n    \r\n    <div className=\"App\">\r\n      <PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}} />\r\n      {/* <PathfindingVisualizer /> */}\r\n      \r\n    </div>\r\n  );\r\n}\r\n\r\n// ReactDOM.render(<PathfindingVisualizer ref={(PathfindingVisualizer) => {window.PathfindingVisualizer = PathfindingVisualizer}}/>, document.getElementById(\"App\"))\r\n// ReactDOM.render(<Page ref={(ourComponent) => {window.ourComponent = ourComponent}} />, document.getElementById(\"app\"));\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}